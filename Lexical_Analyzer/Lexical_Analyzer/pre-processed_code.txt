#include"analysis.h"
void analysis::getStrBuffer(){
char c ='\0';
int buffer_flag = 0;
while(1)
{
c = fgetc(fin);
if(c == EOF)
{
deleNotes();
deleSpaces();
if(buffer_read[buffer_choose].count > 0)
{
strcpy(buffer_end.buffer,buffer_read[buffer_choose].buffer);
buffer_end.count = buffer_read[buffer_choose].count;
buffer_read[buffer_choose].count = 0;
fprintf(fout_pre,"%s\n",buffer_read[buffer_choose].buffer);
spearateStates();
}
break;
}
if(buffer_read[buffer_choose].count == BUFFER_SIZE - 2)
{
buffer_read[buffer_choose].buffer[buffer_read[buffer_choose].count]= c;
int i;
for(i = 0;i < buffer_read[buffer_choose].count;i++)
{
if(isDelimiter(buffer_read[buffer_choose].buffer[i]))
{
int j;
int k;
for(j = 0,k = i + 1;k <= buffer_read[buffer_choose].count;k++,j++)
{
buffer_read[1 - buffer_choose].buffer[j]= buffer_read[buffer_choose].buffer[k];
}
buffer_read[1 - buffer_choose].count = j;
buffer_read[buffer_choose].count = i;
buffer_read[1 - buffer_choose].buffer[j]='\0';
buffer_read[buffer_choose].buffer[i + 1]='\0';
buffer_flag = 1;
break;
}
}
}
else if(c =='\n'&&!note_flag)
{
buffer_read[buffer_choose].buffer[buffer_read[buffer_choose].count]='\0';
}
else if(c =='\n')
{
buffer_read[buffer_choose].buffer[buffer_read[buffer_choose].count]='\0';
}
else{
buffer_read[buffer_choose].buffer[buffer_read[buffer_choose].count++]= c;
continue;
}
deleNotes();
deleSpaces();
if(buffer_read[buffer_choose].count > 0)
{
strcpy(buffer_end.buffer,buffer_read[buffer_choose].buffer);
buffer_end.count = buffer_read[buffer_choose].count;
buffer_read[buffer_choose].count = 0;
fprintf(fout_pre,"%s\n",buffer_read[buffer_choose].buffer);
spearateStates();
}
if(buffer_flag == 1)
{
buffer_read[buffer_choose].count = 0;
buffer_choose = 1 - buffer_choose;
buffer_flag = 0;
}
}
cout <<"The result of lexical analysis has been saved in the res_out.txt file."<< endl;
cout <<"The pre-processed code has been saved in the pre-processed_code.txt file."<< endl;
cout <<"The word_lable has been saved in the word-lable.txt file."<< endl;
}
void analysis::deleNotes(){
char note[BUFFER_SIZE];
char note_count = 0;
bool flag_qoute = 0;
for(int i = 0;buffer_read[buffer_choose].buffer[i]!='\0';i++)
{
if(buffer_read[buffer_choose].buffer[i]=='"')
{
flag_qoute = 1 - flag_qoute;
if(note_flag != 1)
continue;
}
if(flag_qoute == 1)
if(note_flag != 1)
continue;
if(buffer_read[buffer_choose].buffer[i]=='/'||note_flag == 1)
{
if(buffer_read[buffer_choose].buffer[i + 1]=='\0')
{
continue;
}
if(buffer_read[buffer_choose].buffer[i + 1]=='/'&&!note_flag)
{
int j;
for(j = i;buffer_read[buffer_choose].buffer[j]!='\0';j++)
{
note[note_count++]= buffer_read[buffer_choose].buffer[j];
buffer_read[buffer_choose].buffer[j]='\0';
}
note[note_count]='\0';
fprintf(fout,"[×¢ÊÍ]----[ %s ]\n",note);
buffer_read[buffer_choose].count -= note_count;
note_count = 0;
break;
}
if(buffer_read[buffer_choose].buffer[i + 1]=='*'||note_flag == 1)
{
note_flag = 1;
int j;
for(j = i + 2 *(1 - note_flag);buffer_read[buffer_choose].buffer[j]!='\0';j++)
{
note[note_count++]= buffer_read[buffer_choose].buffer[j];
if(!flag_qoute&&buffer_read[buffer_choose].buffer[j]=='*'&&buffer_read[buffer_choose].buffer[j + 1]=='/')
{
note_flag = 0;
note[note_count++]='/';
note[note_count]='\0';
fprintf(fout,"[×¢ÊÍ]----[ %s ]\n",note);
buffer_read[buffer_choose].count -= note_count;
note_count = 0;
break;
}
}
if(note_flag == 0)
j = j + 2;
for(;buffer_read[buffer_choose].buffer[j]!='\0';j++,i++)
{
if(buffer_read[buffer_choose].buffer[j]=='\n')
{
i--;
continue;
}
buffer_read[buffer_choose].buffer[i]= buffer_read[buffer_choose].buffer[j];
}
if(note_flag){
note[note_count]='\0';
fprintf(fout,"[×¢ÊÍ]----[ %s ]\n",note);
buffer_read[buffer_choose].buffer[i]='\0';
buffer_read[buffer_choose].count -= note_count;
break;
}
buffer_read[buffer_choose].buffer[i]='\0';
}
}
}
}
void analysis::deleSpaces(){
bool flag1 = true,flag2 = true;
for(int i = 0;buffer_read[buffer_choose].buffer[i]!='\0';i++)
{
if(buffer_read[buffer_choose].buffer[i]=='"')
flag1 = !flag1;
if(buffer_read[buffer_choose].buffer[i]=='\'')
flag2 = !flag2;
if((buffer_read[buffer_choose].buffer[i]==' '||buffer_read[buffer_choose].buffer[i]=='\t')&&flag1&&flag2)
{
int j = i + 1;
for(;buffer_read[buffer_choose].buffer[j]!='\0'&&(buffer_read[buffer_choose].buffer[j]==' '||buffer_read[buffer_choose].buffer[j]=='\t');j++)
{
}
if(buffer_read[buffer_choose].buffer[j]=='\0')
{
buffer_read[buffer_choose].buffer[i]='\0';
break;
}
if(i == 0)
{
int k = i;
for(;buffer_read[buffer_choose].buffer[j]!='\0';j++,k++)
buffer_read[buffer_choose].buffer[k]= buffer_read[buffer_choose].buffer[j];
buffer_read[buffer_choose].buffer[k]='\0';
i--;
}
else
{
if(j - i >= 2)
{
int k = i + 1;
for(;buffer_read[buffer_choose].buffer[j]!='\0';j++,k++)
buffer_read[buffer_choose].buffer[k]= buffer_read[buffer_choose].buffer[j];
buffer_read[buffer_choose].buffer[k]='\0';
j = i + 1;
}
if(buffer_read[buffer_choose].buffer[j]!='\0'&&((spaceCanDelete(buffer_read[buffer_choose].buffer[j])||(i > 0&&spaceCanDelete(buffer_read[buffer_choose].buffer[i - 1])))))
{
int k = i;
for(;buffer_read[buffer_choose].buffer[j]!='\0';j++,k++)
buffer_read[buffer_choose].buffer[k]= buffer_read[buffer_choose].buffer[j];
buffer_read[buffer_choose].buffer[k]='\0';
i--;
}
}
}
}
}
void analysis::spearateStates()
{
char word[BUFFER_SIZE];
int count = 0;
bool finish = false;
int state = 0;
for(int i = 0;i <= buffer_end.count;i++)
{
switch(state)
{
case 0:
switch(charKind(buffer_end.buffer[i]))
{
case 1:
word[count++]= buffer_end.buffer[i];
state = 1;
break;
case 2:
word[count++]= buffer_end.buffer[i];
state = 2;
break;
case 3:
word[count++]= buffer_end.buffer[i];
state = 3;
break;
case 4:
word[count++]= buffer_end.buffer[i];
state = 4;
break;
case 5:
word[count++]= buffer_end.buffer[i];
state = 5;
break;
case 6:
word[count++]= buffer_end.buffer[i];
state = 6;
break;
case 7:
word[count++]= buffer_end.buffer[i];
state = 7;
break;
case 8:
word[count++]= buffer_end.buffer[i];
state = 8;
break;
case 10:
word[count++]= buffer_end.buffer[i];
state = 10;
break;
default:
word[count++]= buffer_end.buffer[i];
break;
}
break;
case 1:
switch(charKind(buffer_end.buffer[i]))
{
case 1:case 2:case 3:
word[count++]= buffer_end.buffer[i];
break;
default:
word[count]='\0';
i--;
finish = 1;
state = 9;
}
break;
case 2:
switch(charKind(buffer_end.buffer[i]))
{
case 1:
case 2:
word[count++]= buffer_end.buffer[i];
break;
case 7:
if(buffer_end.buffer[i]=='.')
{
word[count++]= buffer_end.buffer[i];
break;
}
else
{
word[count]='\0';
i--;
finish = 1;
state = 9;
}
break;
case 8:
if((buffer_end.buffer[i]=='+'||buffer_end.buffer[i]=='-')&&(buffer_end.buffer[i - 1]=='e'||buffer_end.buffer[i - 1]=='E'))
{
word[count++]= buffer_end.buffer[i];
break;
}
else
{
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
}
default:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
}
break;
case 3:
switch(charKind(buffer_end.buffer[i]))
{
case 1:case 2:case 3:
word[count++]= buffer_end.buffer[i];
break;
default:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
}
break;
case 4:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
case 5:
word[count++]= buffer_end.buffer[i];
if(buffer_end.buffer[i]=='"')
{
if(buffer_end.buffer[i - 1]=='\\')
{
}
else
{
word[count]='\0';
finish = 1;
state = 9;
}
}
break;
case 6:
word[count++]= buffer_end.buffer[i];
if(buffer_end.buffer[i]=='\'')
{
word[count]='\0';
finish = 1;
state = 9;
}
break;
case 7:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
case 8:
switch(charKind(buffer_end.buffer[i]))
{
case 8:case 11:
word[count++]= buffer_end.buffer[i];
break;
default:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
}
break;
case 9:
state = 0;
count = 0;
finish = 0;
i--;
kindJudge(word);
break;
case 10:
switch(charKind(buffer_end.buffer[i]))
{
case 10:
word[count++]= buffer_end.buffer[i];
break;
default:
word[count]='\0';
i--;
finish = 1;
state = 9;
break;
}
break;
default:
break;
}
if(buffer_end.buffer[i + 1]=='\0')
{
word[count]='\0';
kindJudge(word);
break;
}
}
}
void analysis::kindJudge(char* str)
{
int kind = 0;
if(isKeyWord(str)== 1)
{
kind = KeyWord;
}
else if(isSignWord(str)== 1)
kind = SignWord;
else if(isInt(str)== 1)
kind = Integer;
else if(isFloat(str)== 1)
kind = FloatPoint;
else if(isMonocularOperator(str)== 1)
kind = MonocularOperator;
else if(isBinocularOperator(str)== 1)
kind = BinocularOperator;
else if(isDelimiter(str)== 1)
kind = Delimiter;
else if(isBlank(str)== 1)
kind = Blank;
else if(isSeparator(str[0])== 1&&strlen(str)== 1)
kind = Separator;
else if(isBracketsLeft(str[0])== 1&&strlen(str)== 1)
kind = BracketsLeft;
else if(isBracketsRight(str[0])== 1&&strlen(str)== 1)
kind = BracketsRight;
else if(isBracketsLeftBig(str[0])== 1&&strlen(str)== 1)
kind = BracketsLeftBig;
else if(isBracketsRightBig(str[0])== 1&&strlen(str)== 1)
kind = BracketsRightBig;
else if(isEnd(str[0])== 1&&strlen(str)== 1)
kind = End;
else if(isStr(str))
kind = Str;
else if(isChar(str))
kind = Char;
else
kind = WrongWord;
printResult(kind,str,0);
}
void analysis::printResult(int kind,char* str,int opt)
{
if(opt == 1)
{
switch(kind)
{
case KeyWord:
fprintf(fout,"[¹Ø¼ü×Ö]----[%s]\n",str);
break;
case SignWord:
fprintf(fout,"[±êÊ¶·û]----[%s]\n",str);
break;
case Integer:
fprintf(fout,"[ÕûÊý]----[%s]\n",str);
break;
case FloatPoint:
fprintf(fout,"[¸¡µãÊý]----[%s]\n",str);
break;
case MonocularOperator:
fprintf(fout,"[µ¥Ä¿ÔËËã·û]----[%s]\n",str);
break;
case BinocularOperator:
fprintf(fout,"[Ë«Ä¿ÔËËã·û]----[%s]\n",str);
break;
case Delimiter:
fprintf(fout,"[½ç·û]----[%s]\n",str);
break;
case WrongWord:
fprintf(fout,"[´íÎó´Ê]----[%s]\n",str);
break;
case Blank:
fprintf(fout,"[¿Õ¸ñ]----[%s]\n",str);
break;
case Separator:
fprintf(fout,"[·Ö¸ô·û]----[%s]\n",str);
break;
case BracketsLeft:
fprintf(fout,"[×óÀ¨ºÅ]----[%s]\n",str);
break;
case BracketsRight:
fprintf(fout,"[ÓÒÀ¨ºÅ]----[%s]\n",str);
break;
case BracketsLeftBig:
fprintf(fout,"[×ó´óÀ¨ºÅ]----[%s]\n",str);
break;
case BracketsRightBig:
fprintf(fout,"[ÓÒ´óÀ¨ºÅ]----[%s]\n",str);
break;
case End:
fprintf(fout,"[½áÊø·û]----[%s]\n",str);
break;
case Str:
fprintf(fout,"[×Ö·û´®]----[%s]\n",str);
break;
case Char:
fprintf(fout,"[×Ö·û]----[%s]\n",str);
break;
default:
fprintf(fout,"[ÆäËû]----[%s]\n",str);
break;
}
}
else
{
int WordKindCode = 0;
WordKindCode = getWordKindCode(kind,str);
switch(kind)
{
case KeyWord:
fprintf(fout,"[¹Ø¼ü×Ö]----[%d]----[%s]\n",WordKindCode,str);
break;
case SignWord:
fprintf(fout,"[±êÊ¶·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case Integer:
fprintf(fout,"[ÕûÊý]----[%d]----[%s]\n",WordKindCode,str);
break;
case FloatPoint:
fprintf(fout,"[¸¡µãÊý]----[%d]----[%s]\n",WordKindCode,str);
break;
case MonocularOperator:
fprintf(fout,"[µ¥Ä¿ÔËËã·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case BinocularOperator:
fprintf(fout,"[Ë«Ä¿ÔËËã·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case Delimiter:
fprintf(fout,"[½ç·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case WrongWord:
fprintf(fout,"[´íÎó´Ê]----[%d]----[%s]\n",WordKindCode,str);
break;
case Blank:
fprintf(fout,"[¿Õ¸ñ]----[%d]----[%s]\n",WordKindCode,str);
break;
case Separator:
fprintf(fout,"[·Ö¸ô·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case BracketsLeft:
fprintf(fout,"[×óÀ¨ºÅ]----[%d]----[%s]\n",WordKindCode,str);
break;
case BracketsRight:
fprintf(fout,"[ÓÒÀ¨ºÅ]----[%d]----[%s]\n",WordKindCode,str);
break;
case BracketsLeftBig:
fprintf(fout,"[×ó´óÀ¨ºÅ]----[%d]----[%s]\n",WordKindCode,str);
break;
case BracketsRightBig:
fprintf(fout,"[ÓÒ´óÀ¨ºÅ]----[%d]----[%s]\n",WordKindCode,str);
break;
case End:
fprintf(fout,"[½áÊø·û]----[%d]----[%s]\n",WordKindCode,str);
break;
case Str:
fprintf(fout,"[×Ö·û´®]----[%d]----[%s]\n",WordKindCode,str);
break;
case Char:
fprintf(fout,"[×Ö·û]----[%d]----[%s]\n",WordKindCode,str);
break;
default:
fprintf(fout,"[ÆäËû]----[%s]\n",str);
}
}
}
int analysis::getWordKindCode(int kind,char* str)
{
int ret = 0;
switch(kind)
{
case KeyWord:
ret = WordCode[str];
break;
case SignWord:
ret = WordCode["signword"];
break;
case Integer:
ret = WordCode["integer"];
break;
case FloatPoint:
ret = WordCode["float"];
break;
case MonocularOperator:
ret = WordCode[str];
break;
case BinocularOperator:
ret = WordCode[str];
break;
case Delimiter:
ret = WordCode[";"];
break;
case WrongWord:
ret = WordCode["wrongword"];
break;
case Blank:
ret = WordCode["blank"];
break;
case Separator:
ret = WordCode[","];
break;
case BracketsLeft:
ret = WordCode["("];
break;
case BracketsRight:
ret = WordCode[")"];
break;
case BracketsLeftBig:
ret = WordCode["{"];
break;
case BracketsRightBig:
ret = WordCode["}"];
break;
case End:
ret = WordCode["#"];
break;
case Str:
ret = WordCode["string"];
break;
case Char:
ret = WordCode["char"];
break;
default:
ret = -100;
break;
}
return ret;
}
analysis::analysis()
{
buffer_choose = 0;
note_flag = 0;
fin = fopen("code_in.txt","r");
fout = fopen("res_out.txt","w");
fout_pre = fopen("pre-process_code.txt","w");
fout_lable = fopen("word_lable.txt","w");
const int keyword_size = 24;
const int monocular_operator_size = 13;
const int binocular_operator_size = 14;
int cnt = 0;
for(int i = 0;i < keyword_size;i++)
WordCode[keyword[i]]= ++cnt;
for(int i = 0;i < monocular_operator_size;i++)
WordCode[monocular_operator[i]]= ++cnt;
for(int i = 0;i < binocular_operator_size;i++)
WordCode[binocular_operator[i]]= ++cnt;
WordCode["signword"]= ++cnt;
WordCode["wrongword"]= ++cnt;
WordCode["blank"]= ++cnt;
WordCode[";"]= ++cnt;
WordCode[","]= ++cnt;
WordCode["("]= ++cnt;
WordCode[")"]= ++cnt;
WordCode["{"]= ++cnt;
WordCode["}"]= ++cnt;
WordCode["#"]= ++cnt;
WordCode["string"]= ++cnt;
WordCode["char"]= ++cnt;
WordCode["integer"]= ++cnt;
WordCode["float"]= ++cnt;
map<string,int>::iterator iter;
iter = WordCode.begin();
while(iter != WordCode.end()){
fprintf(fout_lable,"%s : %d\n",iter->first.c_str(),iter->second);
iter++;
}
}
analysis::~analysis()
{
fclose(fin);
fclose(fout);
}close(fout);
